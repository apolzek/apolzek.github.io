{
    "version": "https://jsonfeed.org/version/1",
    "title": "apolzek",
    "home_page_url": "https://apolzek.github.io/",
    "feed_url": "https://apolzek.github.io/feed.json",
    "description": null,
    "icon": "https://apolzek.github.io/apple-touch-icon.png",
    "favicon": "https://apolzek.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "apolzek",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://apolzek.github.io/2026/01/25/interview",
            "title": "How I run technical interviews",
            "summary": null,
            "content_text": "cloud, sre, platform.. especifc context ?grpc, http httpsAqui vai a resposta direta e estruturada para a pergunta que voc√™ pediu (como se fosse o candidato respondendo em uma entrevista t√©cnica):a) Tr√™s diferen√ßas fundamentais entre HTTP/1.1 e HTTP/2 que justificam a escolha obrigat√≥ria do HTTP/2 pelo gRPC:Multiplexing (fluxos m√∫ltiplos em uma √∫nica conex√£o TCP)HTTP/1.1: Uma conex√£o TCP s√≥ permite uma requisi√ß√£o/resposta por vez (head-of-line blocking se houver atraso).HTTP/2: Permite m√∫ltiplos streams independentes na mesma conex√£o TCP, sem bloqueio entre eles.Binary framing + compacta√ß√£o de headers (HPACK)HTTP/1.1: Protocolo textual (headers em texto plano, repetitivos).HTTP/2: Usa frames bin√°rios + compress√£o de headers (HPACK), reduzindo overhead de banda e CPU.Suporte nativo a streaming bidirecional e unidirecionalHTTP/1.1: Limitado a request-response; streaming √© for√ßado via hacks (chunked encoding).HTTP/2: Streams full-duplex, permitindo envio cont√≠nuo de dados em ambas as dire√ß√µes sem abrir novas conex√µes.b) Impacto pr√°tico no gRPC em cen√°rios reais de microsservi√ßos:Multiplexing ‚Üí Permite milhares de RPCs simult√¢neas (unary, client streaming, server streaming, bidirectional) em uma √∫nica conex√£o TCP ‚Üí reduz lat√™ncia de setup de conex√µes, evita explos√£o de sockets e melhora throughput em alta taxa de chamadas (ex.: 10k+ RPS entre servi√ßos).Binary framing + HPACK ‚Üí Menor payload na rede (especialmente √∫til com Protobuf, que j√° √© bin√°rio e compacto) ‚Üí menor lat√™ncia em redes com alta lat√™ncia ou baixa largura de banda; menos CPU no parsing/serializa√ß√£o em compara√ß√£o com JSON + texto.Streaming bidirecional ‚Üí Habilita casos reais como chat em tempo real, streaming de logs/telemetria, atualiza√ß√µes cont√≠nuas (ex.: bidirectional streaming para ML inference ou observability push) ‚Üí sem polling ou WebSocket hacks, com baixa lat√™ncia e alta efici√™ncia.c) Por que o gRPC n√£o pode simplesmente cair para HTTP/1.1 sem perder funcionalidades cr√≠ticas? Dois motivos espec√≠ficos:Multiplexing e streaming bidirecional s√£o imposs√≠veis no HTTP/1.1 ‚Üí Sem m√∫ltiplos streams na mesma conex√£o, bidirectional streaming (ex.: chat ou streaming de dados cont√≠nuos) quebra completamente; unary calls ficariam serializadas, causando alto tail latency e baixa throughput.gRPC depende de trailers HTTP/2 para metadados de status e erro ‚Üí O status final do RPC (OK, DEADLINE_EXCEEDED, etc.) √© enviado via HTTP/2 trailers (ap√≥s o body). HTTP/1.1 n√£o tem trailers equivalentes de forma nativa e confi√°vel ‚Üí perda de informa√ß√µes cr√≠ticas de erro/status, quebrando a sem√¢ntica do RPC.",
            "content_html": "<p>cloud, sre, platform.. especifc context ?</p><p>grpc, http https</p><p>Aqui vai a resposta direta e estruturada para a pergunta que voc√™ pediu (como se fosse o candidato respondendo em uma entrevista t√©cnica):a) Tr√™s diferen√ßas fundamentais entre HTTP/1.1 e HTTP/2 que justificam a escolha obrigat√≥ria do HTTP/2 pelo gRPC:Multiplexing (fluxos m√∫ltiplos em uma √∫nica conex√£o TCP)HTTP/1.1: Uma conex√£o TCP s√≥ permite uma requisi√ß√£o/resposta por vez (head-of-line blocking se houver atraso).HTTP/2: Permite m√∫ltiplos streams independentes na mesma conex√£o TCP, sem bloqueio entre eles.Binary framing + compacta√ß√£o de headers (HPACK)HTTP/1.1: Protocolo textual (headers em texto plano, repetitivos).HTTP/2: Usa frames bin√°rios + compress√£o de headers (HPACK), reduzindo overhead de banda e CPU.Suporte nativo a streaming bidirecional e unidirecionalHTTP/1.1: Limitado a request-response; streaming √© for√ßado via hacks (chunked encoding).HTTP/2: Streams full-duplex, permitindo envio cont√≠nuo de dados em ambas as dire√ß√µes sem abrir novas conex√µes.</p><p>b) Impacto pr√°tico no gRPC em cen√°rios reais de microsservi√ßos:Multiplexing ‚Üí Permite milhares de RPCs simult√¢neas (unary, client streaming, server streaming, bidirectional) em uma √∫nica conex√£o TCP ‚Üí reduz lat√™ncia de setup de conex√µes, evita explos√£o de sockets e melhora throughput em alta taxa de chamadas (ex.: 10k+ RPS entre servi√ßos).Binary framing + HPACK ‚Üí Menor payload na rede (especialmente √∫til com Protobuf, que j√° √© bin√°rio e compacto) ‚Üí menor lat√™ncia em redes com alta lat√™ncia ou baixa largura de banda; menos CPU no parsing/serializa√ß√£o em compara√ß√£o com JSON + texto.Streaming bidirecional ‚Üí Habilita casos reais como chat em tempo real, streaming de logs/telemetria, atualiza√ß√µes cont√≠nuas (ex.: bidirectional streaming para ML inference ou observability push) ‚Üí sem polling ou WebSocket hacks, com baixa lat√™ncia e alta efici√™ncia.</p><p>c) Por que o gRPC n√£o pode simplesmente cair para HTTP/1.1 sem perder funcionalidades cr√≠ticas? Dois motivos espec√≠ficos:Multiplexing e streaming bidirecional s√£o imposs√≠veis no HTTP/1.1 ‚Üí Sem m√∫ltiplos streams na mesma conex√£o, bidirectional streaming (ex.: chat ou streaming de dados cont√≠nuos) quebra completamente; unary calls ficariam serializadas, causando alto tail latency e baixa throughput.gRPC depende de trailers HTTP/2 para metadados de status e erro ‚Üí O status final do RPC (OK, DEADLINE_EXCEEDED, etc.) √© enviado via HTTP/2 trailers (ap√≥s o body). HTTP/1.1 n√£o tem trailers equivalentes de forma nativa e confi√°vel ‚Üí perda de informa√ß√µes cr√≠ticas de erro/status, quebrando a sem√¢ntica do RPC.</p>",
            "url": "https://apolzek.github.io/2026/01/25/interview",
            
            
            
            
            
            "date_published": "2026-01-25T00:00:00+00:00",
            "date_modified": "2026-01-25T00:00:00+00:00",
            
                "author":  {
                "name": "apolzek",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://apolzek.github.io/2026/01/20/proposing-a-workflow",
            "title": "Proposing a workflow for tracking and maintaining complex architectures",
            "summary": null,
            "content_text": "You are an SRE and you like having a holistic view of the product. Or maybe you are a Platform Engineer and want to understand every part of the platform and how data flows through it. The problem is that the team does not have this view. Most of the knowledge lives in the heads of the most senior people. The decision-making context stayed with them. What you are left with is an outdated inventory and, if you are lucky, a few partially documented flows :(That is when you roll up your sleeves and start doing reverse engineering of the product or platform. Time to ‚ÄúGive it everything you‚Äôve got‚ÄùIn practice, you start somewhere. You map connections, figure out which server talks to which one, where the databases are, how read and write flows work. What runs on Kubernetes, what is still on VM or Bare metal. A hybrid environment, with cloud mixed in. Even with sophisticated tools, the environment is complex. At some point, you have to go all the way down to the network packet level and run tcpdump without mercy.After a long journey, you finally get an updated architecture diagram. Servers, services, ports, external components, everything in one place. A map that actually makes sense.So, what do you do after that?At this point, you understand the end-to-end flows. Just like a doctor blinks and ‚Äúsees‚Äù human anatomy, you blink and see the entire system/platform. As Uncle Ben said, ‚Äú√üwith great power comes great responsibility‚Äù. Your role now is to help less senior people reach the same level of understanding. The people who support the system also need this view, so they can break out of the endless loop of repetitive on-call actions.This is where you start thinking about how to make this knowledge fluid, accessible, and evolvable. And this is exactly where the workflow I have been enjoying comes in.[WARN] Nothing I am proposing here is new. All of this already exists and works well. If there is any merit here, it is probably just about connecting the dots. ‚ÄúConnect the dots,‚Äù as Steve Jobs once said.The idea is simple: once you finish the architecture drawing, translate it into Mermaid, following some standards. You can define your own, but here are the steps I usually follow. From a napkin sketch to Mermaid.      Add all components, organized into groups and subgroups. VMs are not Kubernetes, so they should be separate groups. Each has its own characteristics, and that should be explicit.        Add the arrows connecting components, but always think in terms of flows. Read vs write flows, primary vs secondary, user vs system. Mermaid supports styling, so take advantage of that. Use different arrow styles, annotations on components, or notes directly on the arrows. Something like a #cash-in tag already adds useful context.        Once you define a visual standard, document it. Create a separate Mermaid diagram that acts as a legend. This is the ‚Äúhow to work with this diagram‚Äù guide. Everyone on the team should follow it. You do not want to be the owner of this diagram. Trust me.        With the flow documented, it is time to work on top of it. Create a page for ADRs (Architecture Decision Records). For each proposed change, document the change itself, the context, the options (P1, P2, P3), what is expected from each, and whether it was accepted or not. If it was accepted, state which one. Depending on the company, this will turn into a GMUD or an RFC, the formal change document.        When you schedule a meeting to discuss the change, if it makes sense, open the Mermaid diagram in Excalidraw. It supports Mermaid natively. Import the diagram without worrying about styles. This is where the team discusses solutions, scribbles, connects and disconnects arrows, and explores possibilities freely.        If the change is approved, execute the GMUD or RFC. Do it with a clear plan: post-execution tests, a rollback plan, notification plan, documented monitoring, and properly tuned alerts. No production heroics.        If everything goes well, update the status of the GMUD, RFC, and the ADR to ‚Äúaccepted,‚Äù clearly stating which solution was chosen, especially if there were multiple options.        Update the official Mermaid diagram with all the changes that came out of the Excalidraw session. Add context and notify the team and stakeholders about the change(post change).  To wrap up..Now that you‚Äôve put in all the work to standardize things, it‚Äôs time to reap the benefits. Your arrows have styles or tags, so you can probably already see where this is going. From here on, this becomes a perfect playground for using LLMs. You can use them not just to sketch things out for you, but also to help you understand your architecture and even give feedback on it. You can ask them to isolate flows, like ‚Äúisolate the flow with red arrows,‚Äù or ‚Äúisolate components with a specific tag, like #cash-in‚Äù. You can also ask questions such as ‚Äúwhat are the weak points in my architecture* ?? ‚Äú.These are just a few ideas, but once your diagrams are structured, the kinds of questions you can ask and the insights you can get grow really fast. **After all that, make some coffee and go listen to good music. ü§†Mermaid legendflowchart LR    A --&gt; B    B --&gt; C    C --&gt; D    D --&gt; E    %% Todos os links da mesma cor/espessura    linkStyle default stroke:#ff4444,stroke-width:3px    %% S√≥ links espec√≠ficos (come√ßa do 0 na ordem que aparecem)    linkStyle 0 stroke:#00cc00,stroke-width:5px    linkStyle 2 stroke:blue,stroke-dasharray: 5 5",
            "content_html": "<p>You are an <strong>SRE</strong> and you like having a holistic view of the product. Or maybe you are a <strong>Platform Engineer</strong> and want to understand every part of the platform and how data flows through it. The problem is that the team does not have this view. Most of the knowledge lives in the heads of the most senior people. The decision-making context stayed with them. What you are left with is an outdated inventory and, if you are lucky, a few partially documented flows :<strong>(</strong></p><p>That is when you roll up your sleeves and start doing reverse engineering of the product or platform. Time to ‚Äú<strong>Give it everything you‚Äôve got</strong>‚Äù</p><p>In practice, you start somewhere. You map connections, figure out which server talks to which one, where the databases are, how read and write flows work. What runs on Kubernetes, what is still on VM or Bare metal. A hybrid environment, with cloud mixed in. Even with sophisticated tools, the environment is complex. At some point, you have to go all the way down to the network packet level and run tcpdump without mercy.</p><p>After a long journey, you finally get an updated architecture diagram. <em>Servers, services, ports, external components</em>, everything in one place. A map that actually makes sense.</p><p>So, what do you do after that?</p><p>At this point, you understand the end-to-end flows. Just like a doctor blinks and ‚Äúsees‚Äù human anatomy, you blink and see the <strong>entire system/platform</strong>. As Uncle Ben said, <em>‚Äú√üwith great power comes great responsibility‚Äù</em>. Your role now is to help less senior people reach the same level of understanding. The people who support the system also need this view, so they can break out of the endless loop of repetitive on-call actions.</p><p>This is where you start thinking about how to make this knowledge fluid, accessible, and evolvable. And this is exactly where the workflow I have been enjoying comes in.</p><p>[WARN] Nothing I am proposing here is new. All of this already exists and works well. If there is any merit here, it is probably just about connecting the dots. ‚Äú<em>Connect the dots</em>,‚Äù as Steve Jobs once said.</p><p>The idea is simple: once you finish the architecture drawing, translate it into Mermaid, following some standards. You can define your own, but here are the steps I usually follow. From a napkin sketch to Mermaid.</p><ol>  <li>    <p><strong>Add all components, organized into groups and subgroups</strong>. VMs are not Kubernetes, so they should be <strong>separate groups</strong>. Each has its own characteristics, and that should be explicit.</p>  </li>  <li>    <p><strong>Add the arrows connecting components</strong>, but always think in terms of flows. <em>Read vs write flows, primary vs secondary, user vs system</em>. Mermaid supports <em>styling</em>, so take advantage of that. Use different arrow styles, annotations on components, or notes directly on the arrows. Something like a <code class=\"language-plaintext highlighter-rouge\">#cash-in</code> tag already adds useful context.</p>  </li>  <li>    <p>Once you define a visual standard, document it. <strong>Create a separate Mermaid diagram that acts as a legend</strong>. This is the ‚Äú<em>how to work with this diagram</em>‚Äù guide. Everyone on the team should <em>follow it</em>. You do not want to be the owner of this diagram. Trust me.</p>  </li>  <li>    <p>With the flow documented, it is time to work on top of it. <strong>Create a page for ADRs</strong> (<em>Architecture Decision Records</em>). For each proposed change, document the change itself, the context, the options (P1, P2, P3), what is expected from each, and whether it was accepted or not. If it was accepted, state which one. Depending on the company, this will turn into a GMUD or an RFC, the formal change document.</p>  </li>  <li>    <p>When you schedule a meeting to discuss the change, if it makes sense, open the <strong>Mermaid diagram in Excalidraw</strong>. It supports Mermaid natively. Import the diagram without worrying about styles. This is where the team <em>discusses solutions, scribbles, connects and disconnects arrows, and explores possibilities freely</em>.</p>  </li>  <li>    <p>If the change is approved, <strong>execute the GMUD or RFC</strong>. Do it with a clear plan: <em>post-execution tests, a rollback plan, notification plan, documented monitoring, and properly tuned alerts</em>. No production heroics.</p>  </li>  <li>    <p>If everything goes well, update the status of the GMUD, RFC, and the ADR to ‚Äúaccepted,‚Äù clearly stating which solution was chosen, especially if there were multiple options.</p>  </li>  <li>    <p><strong>Update the official Mermaid diagram</strong> with all the changes that came out of the Excalidraw session. Add context and notify the team and stakeholders about the change(post change).</p>  </li></ol><p><em>To wrap up</em>..</p><p>Now that you‚Äôve put in all the work to <strong>standardize things</strong>, it‚Äôs time to reap the benefits. Your arrows have styles or tags, so you can probably already see where this is going. From here on, this becomes a perfect playground for using <strong>LLMs</strong>. You can use them not just to sketch things out for you, but also to help you understand your architecture and even give feedback on it. You can ask them to isolate flows, like ‚Äú<em>isolate the flow with red arrows,</em>‚Äù or ‚Äú<em>isolate components with a specific tag, like #cash-in‚Äù. You can also ask questions such as ‚Äú</em>what are the weak points in my architecture* ?? ‚Äú.</p><p>These are just a few ideas, but once your diagrams are structured, the kinds of questions you can ask and the insights you can get grow really fast. **After all that, make some coffee and go listen to good music. ü§†</p><p>Mermaid legend</p><pre><code class=\"language-mermaid\">flowchart LR    A --&gt; B    B --&gt; C    C --&gt; D    D --&gt; E    %% Todos os links da mesma cor/espessura    linkStyle default stroke:#ff4444,stroke-width:3px    %% S√≥ links espec√≠ficos (come√ßa do 0 na ordem que aparecem)    linkStyle 0 stroke:#00cc00,stroke-width:5px    linkStyle 2 stroke:blue,stroke-dasharray: 5 5</code></pre>",
            "url": "https://apolzek.github.io/2026/01/20/proposing-a-workflow",
            
            
            
            
            
            "date_published": "2026-01-20T00:00:00+00:00",
            "date_modified": "2026-01-20T00:00:00+00:00",
            
                "author":  {
                "name": "apolzek",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://apolzek.github.io/2026/01/16/apolzek",
            "title": "apolzek",
            "summary": null,
            "content_text": "J√∫lio, from Cocoric√≥, is the pure embodiment of a curious boy. He lives on a farm, but his mind is always wandering: he asks questions, imagines possibilities, tests slightly crazy hypotheses, and learns along the way. His curiosity isn‚Äôt just about knowing ‚Äúwhat something is,‚Äù but ‚Äúwhy it is that way‚Äù and ‚Äúwhat if it were different.‚Äù This often puts him in confusing situations, but it is also the driving force behind all his discoveries.Like J√∫lio, I am trying to return to the purity of my being and relearn how to learn. This blog is a mixture of technical topics, philosophical reflections, personal confessions, and worldviews. Here, I write primarily for myself, with the intention of being honest rather than performing for the world.Some people use a nickname to hide behind a character. To me, our given name is already a projection of the person we pretend to be. We naturally create a social mask to navigate the world and interact with others. That‚Äôs why apolzek is where I place my essence and express my true identity.If you‚Äôve stumbled upon this, welcome aboard! When you read any post here, know that you‚Äôll be behind the scenes of my mind. Let‚Äôs go together, let‚Äôs go with God.",
            "content_html": "<p><strong>J√∫lio</strong>, from <em>Cocoric√≥</em>, is the pure embodiment of a curious boy. He lives on a farm, but his mind is always wandering: he asks questions, imagines possibilities, tests slightly crazy hypotheses, and learns along the way. His curiosity isn‚Äôt just about knowing ‚Äúwhat something is,‚Äù but ‚Äúwhy it is that way‚Äù and ‚Äúwhat if it were different.‚Äù This often puts him in confusing situations, but it is also the driving force behind all his discoveries.</p><p>Like J√∫lio, I am trying to return to the purity of my being and relearn how to learn. This blog is a mixture of technical topics, philosophical reflections, personal confessions, and worldviews. Here, I write primarily for myself, with the intention of being honest rather than performing for the world.</p><p>Some people use a nickname to hide behind a character. To me, our given name is already a projection of the person we pretend to be. We naturally create a social mask to navigate the world and interact with others. That‚Äôs why <strong>apolzek</strong> is where I place my essence and express my true identity.</p><p>If you‚Äôve stumbled upon this, welcome aboard! When you read any post here, know that you‚Äôll be behind the scenes of my mind. Let‚Äôs go together, let‚Äôs go with <strong>God</strong>.</p><!--Daughter, 2025 Jan 15 you were extubated at Vila da Serra Hospital. I am so happy that it creates indescribable reactions in me. I love you, I love our family, I love life, I love God.--><!-- My birth name, Vin√≠cius Gomes Batista, is the name I was given when I was presented to God and welcomed into this life. It holds my story, my family roots, and a sense of purpose. Over the years, though, that name has picked up so many layers. Social expectations, roles I learned to play, ways I adapted to fit in. Most of the time those things don‚Äôt feel like the real me at my deepest level. That‚Äôs why I created apolzek. It‚Äôs not about replacing Vin√≠cius or turning my back on him. It‚Äôs more like a deliberate practice, almost a quiet sacred space, where I try to bring the real Vin√≠cius closer to who he truly is underneath everything. When I‚Äôm in apolzek mode, I focus on stripping away those extra layers. I try to speak and act with complete honesty toward myself, and I refuse to let the outside world tell me who I‚Äôm supposed to be. In those moments it‚Äôs just me, no masks, standing in front of God.-->",
            "url": "https://apolzek.github.io/2026/01/16/apolzek",
            
            
            
            
            
            "date_published": "2026-01-16T00:00:00+00:00",
            "date_modified": "2026-01-16T00:00:00+00:00",
            
                "author":  {
                "name": "apolzek",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}